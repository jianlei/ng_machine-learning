function vectorImage = imageTo20x20Gray(fileName="../images/myDigit2.png", cropPercentage=0, rotStep=0)%display reduced image and converts for digit classification%20 x 20 pixels black and white images converted in a row vector of 400 real numbers. %Each pixel is represented by a real number between -1.0 to 1.0, %meaning -1.0 equal black and 1.0 equal white (any number in between is a shade of gray, and number 0.0 is exactly the middle gray).%A color image is returned as an MxNx3 matrix%Grayscale and black-and-white images are of size MxNImage3DmatrixRGB = imread(fileName);  %619x349x3% Convert to NTSC image (YIQ)Image3DmatrixYIQ = rgb2ntsc(Image3DmatrixRGB);  %619x349x3% Convert to grays keeping only luminance (Y) and discard chrominance (IQ)%Image3DmatrixYIQ(:,:,1) is Y, luma%Image3DmatrixYIQ(:,:,2) is I, chrominance%Image3DmatrixYIQ(:,:,3) is Q, quadratureImage2DmatrixBW  = Image3DmatrixYIQ(:,:,1);  %619x349% Get the size of the image, [619,349]oldSize = size(Image2DmatrixBW);   %-----------------------------------------------------------------------------------% Obtain crop size toward centered square (cropDelta)% ...will be zero for the already minimum dimension% ...and if the cropPercentage is zero, % ...both dimensions are zero% ...meaning that the original image will go intact to croppedImage%[135,0]   		[619,349]-349=[270,0]           50cropDelta = floor((oldSize - min(oldSize)) .* (cropPercentage/100));% Compute the desired final pixel size for the original image, [484,349]finalSize = oldSize - cropDelta;% Compute each dimension origin for croping, [68,1]cropOrigin = floor(cropDelta / 2) + 1;% Compute each dimension copying size, [551,349]copySize = cropOrigin + finalSize - 1;% Copy just the desired cropped image from the original B&W image, (68:551, 1:349)croppedImage = Image2DmatrixBW(cropOrigin(1):copySize(1), cropOrigin(2):copySize(2));%imshow(croppedImage);% Resolution scale factors: [rows cols], [0.041322   0.057307]scale = [20 20] ./ finalSize;% Compute back the new image size (extra step to keep code general) [20 20]newSize = max(ceil(scale .* finalSize), 1);% Compute a re-sampled set of indices:(20x20)%[13, 37, 61, 85, 109, 134, 158, 182, 206, 230, 255, 279, 303, 327, 351, 376, 400, 424, 448, 472]%[9, 27, 44, 62, 79, 96, 114, 131, 149, 166, 184, 201, 219, 236, 254, 271, 288, 306, 323, 341]rowIndex = min(round(((1:newSize(1))-0.5)./scale(1)+0.5), finalSize(1));colIndex = min(round(((1:newSize(2))-0.5)./scale(2)+0.5), finalSize(2));% Copy just the indexed values from old image to get new imagenewImage = croppedImage(rowIndex,colIndex,:);%imshow(newImage);% Rotate if needed: -1 is CW, 0 is no rotate, 1 is CCWnewAlignedImage = rot90(newImage, rotStep);%imshow(newAlignedImage);% Invert black and whiteinvertedImage = - newAlignedImage;%imshow(invertedImage);% Find min and max grays values in the imagemaxValue = max(invertedImage(:)); %-0minValue = min(invertedImage(:)); %-0.62207% Compute the value range of actual graysdelta = maxValue - minValue; %0.62207% Normalize grays between 0 and 1normImage = (invertedImage - minValue) / delta;%imshow(normImage);% Add contrast. Multiplication factor is contrast control.contrastedImage = sigmoid((normImage -0.5) * 5);%imshow(contrastedImage)% Show image as seen by the classifierfigure;imshow(contrastedImage, [-1, 1] );% Output the matrix as a unrolled vector, 1x400vectorImage = reshape(contrastedImage, 1, newSize(1)*newSize(2));end